# SRS Adapter 开发思路 - 通俗解释

## 🎯 核心问题：我们想做什么？

想象一下，SRS 是一个大型**多媒体转换中心**，它能接收视频流，然后分发给不同平台的观众。

但是，**SRS 原本只认识几种"通用语言"**（比如 RTMP、HTTP-FLV 等标准协议）。

我们的问题是：**如果我们有自己公司的私有协议（比如叫 MyProto），想接入 SRS，该怎么办？**

---

## 💡 解决方案：设计一个"翻译官"系统

我们设计的思路，就像在 SRS 前面加了一套**"万能翻译系统"**：

```
外部各种协议 (MyProto、RTP、或者其他私有协议)
        ↓
    【翻译官系统】← 这就是我们开发的 Adapter 层
        ↓
   统一的标准格式 (标准帧)
        ↓
    SRS 核心系统 (原有的分发功能)
        ↓
多种输出格式 (RTMP、HLS、WebRTC 等)
```

---

## 🏗️ 核心组件（用生活中的例子理解）

### 1. **AdapterListener（接待员）**
**作用：** 在门口等待，接收来自网络的数据包

**类比：** 就像酒店前台，负责接待各种语言的客人（不同协议的数据）

### 2. **AdapterManager（调度中心）**
**作用：** 根据不同的协议类型，选择对应的"翻译官"

**类比：** 就像公司的人事部门，有一本员工花名册（注册表），知道"英语客人的话找张三翻译，法语客人的话找李四翻译"

```cpp
// 伪代码示例
当收到 MyProto 协议的数据时：
    → 查找注册表："myproto" 对应 MyProtoAdapter
    → 创建这个适配器来处理数据
```

### 3. **IAdapter（翻译官接口）**
**作用：** 定义所有"翻译官"都必须会做的事情

**类比：** 就像给所有翻译官制定的"工作标准"：
- ✅ 必须能"听懂"原始数据（`feed()` - 接收数据）
- ✅ 必须能"翻译"成标准格式（`parseFrame()` - 解析帧）
- ✅ 必须能"输出"标准结果（产出标准帧）

### 4. **MyProtoAdapter（具体翻译官）**
**作用：** 专门负责把 MyProto 协议翻译成标准格式

**类比：** 一个专门翻译中文的翻译官，他知道：
- 如何识别 MyProto 的数据包格式
- 如何提取视频帧、音频帧
- 如何处理时间戳
- 如何转换成分辨率、码率等信息

### 5. **StdFrame（标准格式）**
**作用：** 统一的数据格式，无论什么协议进来，最终都转换成这个格式

**类比：** 就像联合国的官方语言（英语），无论你是中国人、法国人还是德国人，最终都用英语交流，这样大家都能理解。

标准帧包含：
- 视频/音频数据
- 时间戳（什么时候播放）
- 关键帧标记（I帧、P帧、B帧）
- 编码格式（H264、H265等）
- 分辨率、码率等信息

### 6. **FrameToSourceBridge（桥梁）**
**作用：** 把标准格式的数据"推送"给 SRS 核心系统

**类比：** 就像快递员，把我们整理好的标准包裹（标准帧）送到 SRS 的处理中心

---

## 🔄 完整工作流程（用场景理解）

假设有一个客户端，用 MyProto 协议发送视频流：

### 步骤 1：接待
```
客户端 → 发送 MyProto 数据包 → AdapterListener 在端口9000接收
```

### 步骤 2：识别与调度
```
AdapterManager 查看数据包：
  "这是什么协议？看起来是 MyProto！"
  → 查看注册表："myproto" = MyProtoAdapter
  → "好的，让 MyProtoAdapter 来处理"
```

### 步骤 3：翻译
```
MyProtoAdapter 开始工作：
  1. 接收原始数据（feed）
  2. 解析 MyProto 协议格式
  3. 提取视频帧、音频帧
  4. 转换时间戳
  5. 组织成标准帧（StdFrame）
```

### 步骤 4：交付
```
标准帧 → FrameBus → FrameToSourceBridge → SRS LiveSource
```

### 步骤 5：分发
```
SRS 核心系统拿到标准帧后：
  → "好的，这是标准格式，我可以处理了！"
  → 自动转换成 RTMP、HLS、WebRTC 等多种格式
  → 分发给不同的观众
```

---

## 🎁 这个设计的优势

### ✅ **可插拔**
就像 USB 接口，你想接入新协议？写一个新的 Adapter 类，注册一下就行，不用改 SRS 核心代码。

### ✅ **解耦合**
翻译系统和 SRS 核心系统是分开的。翻译系统出问题，不会影响 SRS 核心；SRS 升级，也不用改翻译系统。

### ✅ **可复用**
SRS 的所有功能（RTMP、HLS、WebRTC、SRT 等）我们都能用！因为最终都转换成标准格式，SRS 认识标准格式。

### ✅ **易扩展**
以后有了新协议（比如公司又开发了 NewProto），只需要：
1. 创建一个 `NewProtoAdapter.cpp`
2. 实现 `IAdapter` 接口
3. 注册到 `AdapterManager`
4. 搞定！

---

## 🛠️ 技术实现要点

### 1. **统一接口（IAdapter）**
所有适配器都必须实现这几个方法：
```cpp
start()      // 初始化
feed()       // 接收原始数据
parseFrame() // 解析成标准帧
flush()      // 刷新缓冲区
close()      // 关闭
```

### 2. **标准格式（StdFrame）**
所有协议最终都转换成：
```cpp
struct StdFrame {
    int64_t dts_ms;          // 解码时间戳
    int64_t pts_ms;          // 显示时间戳
    bool keyframe;           // 是否关键帧
    std::string codec;       // 编码格式（H264/H265/AAC等）
    std::vector<uint8_t> payload; // 视频/音频数据
    // ... 其他信息
}
```

### 3. **插件机制（AdapterManager）**
像插件系统一样，动态注册：
```cpp
// 注册 MyProto 适配器
AdapterManager::instance().register_factory("myproto", 
    []() { return new MyProtoAdapter(); });
```

---

## 📝 举个实际例子

假设我们收到一个 MyProto 数据包：

```
原始数据：[0xAB 0xCD 0xEF ...] (二进制数据)
```

MyProtoAdapter 的工作：
1. **识别**：看数据头，确认是 MyProto 格式
2. **解析**：按照 MyProto 协议规则，提取：
   - 视频帧数据
   - 时间戳：12345ms
   - 编码格式：H264
   - 分辨率：1920x1080
3. **转换**：组织成标准帧
   ```cpp
   StdFrame frame;
   frame.dts_ms = 12345;
   frame.pts_ms = 12345;
   frame.codec = "H264";
   frame.keyframe = true;
   frame.payload = {视频数据...};
   ```
4. **交付**：把标准帧送给 SRS

SRS 收到标准帧后：
- "OK，这是标准格式，我知道怎么处理"
- 自动转成 RTMP、HLS 等格式
- 分发给观众

---

## 🎯 总结

**核心思想：**

> **把"翻译"工作从 SRS 核心中剥离出来，形成一个独立的、可插拔的适配层。这样，我们可以快速接入新协议，而不需要改动 SRS 的核心代码。**

**实现方式：**

> **通过"工厂模式 + 策略模式"，让不同的协议适配器可以动态注册和创建，最终都转换成统一的标准格式，交给 SRS 处理。**

**好处：**

> **快速接入、安全可靠、易于维护、功能复用。**

---

这就是我们的开发思路！用一句话总结：

**"设计一套翻译系统，让各种私有协议都能接入 SRS，并且不需要修改 SRS 核心代码"**

---

## 💻 实际代码示例

### 1. 注册适配器（在 SRS 启动时）

```cpp
// 在 srs_app_caster_myproto.cpp 中
srs_error_t SrsMyProtoCasterListener::listen() {
    // 注册 MyProto 适配器工厂
    static auto factory_func = []() -> IAdapter* {
        return new MyProtoAdapter();
    };
    AdapterManager::instance().register_factory("myproto", factory_func);
    
    // 启动监听器...
}
```

### 2. 适配器接收数据

```cpp
// MyProtoAdapter 接收原始数据
srs_error_t MyProtoAdapter::feed(const uint8_t* data, size_t nbytes) {
    // 把数据放入缓冲区
    input_buffer_.insert(input_buffer_.end(), data, data + nbytes);
    
    // 解析数据包
    while (buffer_->left() > 0) {
        switch (state_) {
            case STATE_HEADER:
                parseHeader();  // 解析数据包头部
                break;
            case STATE_PAYLOAD:
                parsePayload(); // 解析数据包内容
                break;
            case STATE_COMPLETE:
                createStdFrame(); // 转换成标准帧
                break;
        }
    }
}
```

### 3. 解析 MyProto 协议

```cpp
// 解析 MyProto 数据包头
srs_error_t MyProtoAdapter::parseHeader() {
    frame_header_.magic = buffer_->read_4bytes();      // 魔术字（验证用）
    frame_header_.length = buffer_->read_4bytes();     // 数据长度
    frame_header_.type = buffer_->read_1bytes();       // 帧类型（视频/音频）
    frame_header_.codec = buffer_->read_1bytes();      // 编码格式（H264/H265/AAC等）
    frame_header_.timestamp = buffer_->read_8bytes();  // 时间戳
    frame_header_.flags = buffer_->read_1bytes();      // 标志位（关键帧等）
    // ... 其他字段
}
```

### 4. 转换成标准帧

```cpp
// 创建标准帧
srs_error_t MyProtoAdapter::createStdFrame() {
    StdFrame frame;
    
    // 设置时间戳
    frame.h.dts_ms = timestamp_ms;
    frame.h.pts_ms = timestamp_ms;
    
    // 设置编码格式
    if (frame_header_.codec == 0) {
        frame.h.codec = "H264";
    } else if (frame_header_.codec == 1) {
        frame.h.codec = "H265";
    }
    
    // 设置是否为关键帧
    frame.h.keyframe = (frame_header_.flags & 0x01) != 0;
    
    // 设置视频/音频数据
    frame.payload = payload_buffer_;
    
    // 通过 FrameBus 发送给 SRS
    frame_bus_->push(frame);
    
    return srs_success;
}
```

---

## 🎨 可视化架构图

```
┌─────────────────────────────────────────────────────────────┐
│                     客户端（MyProto协议）                     │
│            发送视频流数据包（自定义格式）                      │
└──────────────────────────┬──────────────────────────────────┘
                           │ TCP/UDP 网络传输
                           ▼
┌─────────────────────────────────────────────────────────────┐
│              AdapterListener（监听器）                        │
│  • 监听端口 9000                                            │
│  • 接收网络连接                                              │
│  • 管理连接生命周期                                          │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│             AdapterManager（调度中心）                        │
│  ┌──────────────────────────────────────┐                   │
│  │ 注册表（协议名 → 适配器工厂）         │                   │
│  │ "myproto" → MyProtoAdapter          │                   │
│  │ "rtp_ps"  → RTPPSAdapter (未来)     │                   │
│  │ "xxx"     → XXXAdapter (未来)       │                   │
│  └──────────────────────────────────────┘                   │
│  根据协议类型，创建对应的适配器实例                          │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│          MyProtoAdapter（具体适配器）                         │
│  ┌──────────────────────────────────────┐                   │
│  │ 1. feed(data)                        │ 接收原始数据      │
│  │ 2. parseHeader()                     │ 解析协议头        │
│  │ 3. parsePayload()                    │ 解析数据内容      │
│  │ 4. createStdFrame()                  │ 创建标准帧        │
│  │ 5. 处理时间戳、B帧、参数集等          │                   │
│  └──────────────────────────────────────┘                   │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼ 输出标准帧（StdFrame）
┌─────────────────────────────────────────────────────────────┐
│              FrameBus（帧总线）                               │
│  • 缓冲标准帧                                               │
│  • 处理乱序                                                 │
│  • 流量控制                                                 │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│      FrameToSourceBridge（桥接器）                           │
│  把标准帧转换成 SRS 能理解的格式                             │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│           SRS LiveSource（SRS核心）                          │
│  • 接收标准格式的视频/音频帧                                 │
│  • 自动转换成多种输出格式                                    │
│    ├─ RTMP    (rtmp://...)                                  │
│    ├─ HLS     (http://.../xxx.m3u8)                         │
│    ├─ HTTP-FLV (http://.../xxx.flv)                         │
│    ├─ WebRTC  (webrtc://...)                                │
│    └─ SRT     (srt://...)                                   │
└─────────────────────────────────────────────────────────────┘
```

---

## ❓ 常见问题

### Q1: 为什么不直接改 SRS 核心代码？

**A:** 因为：
- SRS 是第三方开源项目，直接改核心代码会让后续升级很困难
- 多套协议混在一起会让代码变得复杂难维护
- 我们的协议可能和 SRS 的标准协议差异很大，混在一起容易出问题

### Q2: 为什么需要"标准帧"？

**A:** 因为不同的协议格式完全不同：
- MyProto 可能是：`[魔数字][长度][类型][数据]`
- RTMP 可能是：`[块头][时间戳][数据]`
- RTP 可能是：`[RTP头][负载]`

但它们都包含相同的信息：视频数据、时间戳、关键帧标记等。

标准帧就是把这些共同信息提取出来，用统一格式表达，这样 SRS 就不用关心数据是从哪个协议来的了。

### Q3: 性能会有影响吗？

**A:** 影响很小：
- 数据只是"翻译"一下，没有额外的编码/解码
- 使用内存缓冲，不涉及磁盘IO
- 适配器代码简单高效

### Q4: 如何添加新协议？

**A:** 只需要3步：

```cpp
// 1. 创建新的适配器类
class NewProtoAdapter : public IAdapter {
    // 实现所有接口方法
};

// 2. 注册适配器
AdapterManager::instance().register_factory("newproto",
    []() { return new NewProtoAdapter(); });

// 3. 在配置文件中启用
stream_caster {
    caster newproto;
    listen 9001;
}
```

### Q5: 适配器出问题会影响 SRS 吗？

**A:** 不会！因为：
- 适配器和 SRS 核心是分开的
- 适配器错误会被捕获，不会崩溃整个系统
- 可以独立重启适配器，不影响其他协议

---

## 🚀 开发建议

### 1. **从简单开始**
先实现一个最基础的适配器，能接收数据、解析、转换就行。功能慢慢加。

### 2. **做好日志**
适配器里多写日志，这样出问题时容易定位：
```cpp
srs_trace("MyProto: received %d bytes, state=%d", nbytes, state_);
srs_warn("MyProto: invalid timestamp dts=%lld", dts_ms);
```

### 3. **处理异常情况**
- 网络中断
- 数据包不完整
- 时间戳异常
- 内存不足

### 4. **单元测试**
为适配器的核心逻辑写单元测试，比如时间戳转换、帧解析等。

---

## 📚 相关文件位置

```
srs-source/trunk/src/app/
├── adapter/                          # 适配器抽象层
│   ├── iadapter.hpp                 # 接口定义
│   ├── adapter_manager.hpp/.cpp     # 管理器
│   ├── adapter_listener.hpp/.cpp    # 监听器
│   ├── std_frame.hpp                # 标准帧定义
│   ├── frame_bus.hpp/.cpp           # 帧总线
│   ├── frame_to_source_bridge.hpp   # 桥接器
│   └── adapters/
│       └── myproto_adapter.cpp      # MyProto适配器实现
│
├── srs_app_caster_myproto.cpp       # 桥接到SRS的Caster系统
└── srs_app_config.cpp               # 配置文件解析（支持myproto配置）
```

---

**希望这个说明能帮助你理解我们的开发思路！** 🎉
